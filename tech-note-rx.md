# 기술기록(RX)

[![GPL2](https://img.shields.io/badge/license-GPL2-yellowgreen.svg)](https://github.com/parkkw09/parkSync/edit/master/LICENSE)

```
#rx노트 9
구독중인 명령어가 에러가 나면 이를 복구 하고 다시 시도해야 하는 경우가 있다.
문제는 이 구독중인 Observable이 N개이고 이것들이 동시에 작동되는 것이라면
에러를 복구하기 전엔 모든 emit이 에러나버린다. 그리고는 예상과는 다르게 동작한다.
비동기처리이다 보니 충분히 감수해야 하는 상황이긴 하나 사용자 입장에선 용납이 안될터!
아무리 생각해도 방법은 블로킹 밖에 없었다.
큐에 메세지를 넣어놓고 처리하듯 Rx에도 비슷한게 분명히 있을 것 같아서 이것저것 확인해보니
핫 옵저블을 처리하기 위한 명령어중 ReplaySubject라는 것이 있다. 이는 구독을 요청하는 모든 시점(구독자)에게
그동안 쌓인 모든 emit을 다 던진다. 즉, queueing이 가능하다. 물론 잘못쓰면 참사가 벌어지지만(전부다 구독완료되는 시점은 내가 알수가 없음)
확실히 방법은 존재한다. 처리가 되긴 했으나 세가지 문제점이 남아 있는데
모든 구조를 이렇게 바꿀것이냐?와 에러가 나는 시점에 쏟아지는 emit은 답이 없다는 것, 마지막으로
에러 복구 시점부터 완료까지는 무조건 블로킹이 걸려서 순차처리가 되야 할 가능성이 높다는 것이다.
순차처리의 경우 잘 작업하면 기존 병렬처리를 유지할 순 있겠으나 전체 코드에 이것을 고려하기엔
오바 스펙이 되고(에러날 가능성이 별로없는 문제이기에) 내 손떠난 emit은 회수할 방법이 없다는 것이다.
결론은 모든 것이 시작되는 시점에 에러여부를 확인하는 것으로 마무리되었으나
어떻게든 고칠수는 있으나 효율면에서 방법을 고민해야 하는 과제였다.
요 몇일 많이 배웠네 ㅋ
2019.09.17
```

```
#rx노트 8
이제 어느정도 마무리도 되어가고
그동안 모델 레이어에서만 사용을 고집했던 것(실제론 뷰모델)을 벗어나
뷰에서도 접근을 시도해 봐야겠다. 잘만쓰면 각종 예외처리 및 기타 잡다한것이
전부 해결이 되는 맥가이버 칼이다.
물론 내가 맥가이버 칼을 만들수있어야 하는건 함정.
2019.08.23
```

```
#rx노트 7
결국 코드에 coroutine kotlin이 들어왔다.
왜 있는지도 알고 rx랑 비슷한 것도 알기 때문에
한번 익혀나 볼까? 교보재로 딱이군 이런생각이 들긴하지만
개발자라면 가장 피해야 하는 상황이 여러번 코드 내에 등장하고 있는데
지금 이 상황도 그중 하나이다.
나중에 무슨 상황이 일어날진 잘 알고 있다.
그렇다고 배워가는 입장에 내 식대로 무조건 밀어 붙히기도 뭐하고
한번 끝까지 만들어나 보고 싶다.
지금 내가 배우려는 것을 모두 동원하여...
2019.04.19
```

```
#rx노트 6
Observable을 계속 쓸것인가 Single로 교체할 것인가
그 것이 문제로다.
2019.04.01
```

```
#rx노트 5
데이터베이스 쓰기가 겁나 편해졌어용~
아...생각해보니 thread처리 안했네 ㅋㅋㅋㅋ
2018. 10. 17. 오후 5:40
```

```
#rx노트 4
3콤보 정돈 처리해줘야 rx지.
1) 데이터A를 가져온다.
2) 데이터 A를 저장한다.
3) 데이터 A의 B를 가져온다.
4) 데이터 B를 저장한다.
4-1) 저장이 완료될 때 까지 기다린다.
5) 데이터 A를 꺼내면서 동시에 데이터 B를 꺼낸다.
6) 데이터 A와 B의 조합으로 데이터 C를 만든다.
7) 데이터 C를 저장한다.
7-1) 데이터 C가 저장이 완료가 될 때 까지 기다린다.
2018. 10. 1. 오후 11:09
```

```
#rx노트 3
하란대로 안하고 내 맘대로 만들었더니 메모리가 줄줄세네ㅠㅠ
2018. 8. 7. 오후 12:37
```

```java
#rx노트 2
reduce, bifunction
var sales = ArrayList<Pair<String, String>>()
sales.add("TV" to "2500")
sales.add("Camera" to "300")
sales.add("TV" to "1600")
sales.add("Phone" to "800")
sales.add("TV" to "400")

val tvSales: Maybe<String> = Observable.fromIterable(sales)
.filter{sale -> "TV" == sale.first}
.map{sale -> sale.second}
.reduce{
sale1, sale2 -> "[[$sale1] + [$sale2] = [${sale1 + sale2}]]"
}
tot = [[[[2500] + [1600] = [25001600]]] + [400] = [[[2500] + [1600] = [25001600]]400]]

A = [[2500] + [1600] = [25001600]]
tot = [[A] + [400] = [A]400]]

이해하기 무척이나 어렵군요 ㅎㅎㅎㅎㅎㅎㅎㅎㅎ
2018. 6. 22. 오후 1:12
```

```
#rx노트 1
장난나랑지금하냐
2018. 6. 21. 오후 6:15
```
