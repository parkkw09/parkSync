# 기술기록(RX)

[![GPL2](https://img.shields.io/badge/license-GPL2-yellowgreen.svg)](https://github.com/parkkw09/parkSync/edit/master/LICENSE)

```
#rx노트 10
오늘 이런 이야기를 들었다.
발행된 데이터가 1개이므로 Single로 사용했다.
맞다. 나도 처음에 이런 블로그 글을 보고 Rest관련 Rx 구문은 Single로 처리했었다.
그러나 곧 문제점에 봉착을 했다. Repository방식으로 처리하는 핵심중에 하나가 모델이 만들어지고
인스턴스화 시키는 과정에서 이를 로컬에 저장할 것인가 혹은 로컬/리모트 데이터 중 어떤 것을 선택할 것인가? 를 판단하는 것과
아무리 Json으로 들어오는 데이터라고 하지만 서버 사이드의 데이터와 클라이언트 사이드의 데이터 핸들링 방식은 차이가 존재하기 때문에
서로 간의 간섭을 최소화 하기 위해 데이터 가공 혹은 마샬링을 시도한다.(나는) 의미를 모르면 쓸떼없이 두번일하는 걸로 보이지만
이기종 제어를 많이 하다보면 이는 당연한 과정이다.
여튼!
이걸 하다보니 자연스레 리스트에 대한 가공이 들어가는데 리스트는 연속된 데이터이므로 Single만으로 제어를 할 수가 없다.
그래서 결국 다시 Observable로 변경해서 쓰고 있는데 지금은 Single로 맞춰놓을 수도 있고
그냥 Observable로 해버릴 수도 있고... 솔직히 자유자재 가능하다. 물론 이를 위해 코드를 다시 보니 보완할 점도 눈에 보이고....
한동안 잊고 있던 것인데 만들 당시엔 저양반들은 이런작업을 분명할텐데 왜 Single로 다 가능하다 했을까? 라는 말이 이해가 되지 않았었다.
지금 생각해보면(최근 동료들 작업해놓은 것도 그렇고) 마샬링을 따로 안하면 말이된다.
서버/클라가 쿵짝이 잘맞으면 솔직히 마샬링 안해도됨.
끝.
2019.09.18
```

```
#rx노트 9
구독중인 명령어가 에러가 나면 이를 복구 하고 다시 시도해야 하는 경우가 있다.
문제는 이 구독중인 Observable이 N개이고 이것들이 동시에 작동되는 것이라면
에러를 복구하기 전엔 모든 emit이 에러나버린다. 그리고는 예상과는 다르게 동작한다.
비동기처리이다 보니 충분히 감수해야 하는 상황이긴 하나 사용자 입장에선 용납이 안될터!
아무리 생각해도 방법은 블로킹 밖에 없었다.
큐에 메세지를 넣어놓고 처리하듯 Rx에도 비슷한게 분명히 있을 것 같아서 이것저것 확인해보니
핫 옵저블을 처리하기 위한 명령어중 ReplaySubject라는 것이 있다. 이는 구독을 요청하는 모든 시점(구독자)에게
그동안 쌓인 모든 emit을 다 던진다. 즉, queueing이 가능하다. 물론 잘못쓰면 참사가 벌어지지만(전부다 구독완료되는 시점은 내가 알수가 없음)
확실히 방법은 존재한다. 처리가 되긴 했으나 세가지 문제점이 남아 있는데
모든 구조를 이렇게 바꿀것이냐?와 에러가 나는 시점에 쏟아지는 emit은 답이 없다는 것, 마지막으로
에러 복구 시점부터 완료까지는 무조건 블로킹이 걸려서 순차처리가 되야 할 가능성이 높다는 것이다.
순차처리의 경우 잘 작업하면 기존 병렬처리를 유지할 순 있겠으나 전체 코드에 이것을 고려하기엔
오바 스펙이 되고(에러날 가능성이 별로없는 문제이기에) 내 손떠난 emit은 회수할 방법이 없다는 것이다.
결론은 모든 것이 시작되는 시점에 에러여부를 확인하는 것으로 마무리되었으나
어떻게든 고칠수는 있으나 효율면에서 방법을 고민해야 하는 과제였다.
요 몇일 많이 배웠네 ㅋ
2019.09.17
```

```
#rx노트 8
이제 어느정도 마무리도 되어가고
그동안 모델 레이어에서만 사용을 고집했던 것(실제론 뷰모델)을 벗어나
뷰에서도 접근을 시도해 봐야겠다. 잘만쓰면 각종 예외처리 및 기타 잡다한것이
전부 해결이 되는 맥가이버 칼이다.
물론 내가 맥가이버 칼을 만들수있어야 하는건 함정.
2019.08.23
```

```
#rx노트 7
결국 코드에 coroutine kotlin이 들어왔다.
왜 있는지도 알고 rx랑 비슷한 것도 알기 때문에
한번 익혀나 볼까? 교보재로 딱이군 이런생각이 들긴하지만
개발자라면 가장 피해야 하는 상황이 여러번 코드 내에 등장하고 있는데
지금 이 상황도 그중 하나이다.
나중에 무슨 상황이 일어날진 잘 알고 있다.
그렇다고 배워가는 입장에 내 식대로 무조건 밀어 붙히기도 뭐하고
한번 끝까지 만들어나 보고 싶다.
지금 내가 배우려는 것을 모두 동원하여...
2019.04.19
```

```
#rx노트 6
Observable을 계속 쓸것인가 Single로 교체할 것인가
그 것이 문제로다.
2019.04.01
```

```
#rx노트 5
데이터베이스 쓰기가 겁나 편해졌어용~
아...생각해보니 thread처리 안했네 ㅋㅋㅋㅋ
2018. 10. 17. 오후 5:40
```

```
#rx노트 4
3콤보 정돈 처리해줘야 rx지.
1) 데이터A를 가져온다.
2) 데이터 A를 저장한다.
3) 데이터 A의 B를 가져온다.
4) 데이터 B를 저장한다.
4-1) 저장이 완료될 때 까지 기다린다.
5) 데이터 A를 꺼내면서 동시에 데이터 B를 꺼낸다.
6) 데이터 A와 B의 조합으로 데이터 C를 만든다.
7) 데이터 C를 저장한다.
7-1) 데이터 C가 저장이 완료가 될 때 까지 기다린다.
2018. 10. 1. 오후 11:09
```

```
#rx노트 3
하란대로 안하고 내 맘대로 만들었더니 메모리가 줄줄세네ㅠㅠ
2018. 8. 7. 오후 12:37
```

```java
#rx노트 2
reduce, bifunction
var sales = ArrayList<Pair<String, String>>()
sales.add("TV" to "2500")
sales.add("Camera" to "300")
sales.add("TV" to "1600")
sales.add("Phone" to "800")
sales.add("TV" to "400")

val tvSales: Maybe<String> = Observable.fromIterable(sales)
.filter{sale -> "TV" == sale.first}
.map{sale -> sale.second}
.reduce{
sale1, sale2 -> "[[$sale1] + [$sale2] = [${sale1 + sale2}]]"
}
tot = [[[[2500] + [1600] = [25001600]]] + [400] = [[[2500] + [1600] = [25001600]]400]]

A = [[2500] + [1600] = [25001600]]
tot = [[A] + [400] = [A]400]]

이해하기 무척이나 어렵군요 ㅎㅎㅎㅎㅎㅎㅎㅎㅎ
2018. 6. 22. 오후 1:12
```

```
#rx노트 1
장난나랑지금하냐
2018. 6. 21. 오후 6:15
```
