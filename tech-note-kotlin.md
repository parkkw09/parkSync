# 기술기록(코틀린)

[![GPL2](https://img.shields.io/badge/license-GPL2-yellowgreen.svg)](https://github.com/parkkw09/parkSync/edit/master/LICENSE)

```
#코틀린노트 28
최근에는 UI를 정신없이 뽑아내다 보니 코틀린에 대한 기술적 접근 보다는 XML과 사투를 벌이고 있다.
화면구성을 위해서 XML을 만들다보면 코드가 너무 길어지는데 그렇게들 쓰라고 하는
ConstraintLayout이 한몫을 한다. 얘는 RelativeLayout처럼 부모를 기준으로 혹은 상대 컴포넌트를 기준으로 위치를
잡아줘야 한다. 반드시 잡아야 하기 때문에 리니어대비 코드가 엄청 늘어난다. 그래도 위치가 명확하게 선언되기 때문에
보기에는 좋다. 어찌되었건 이러다보니 코드는 엄청 늘어나고 실제 바인딩 코드, 뷰/모델 코드보다 훨씬 길어지는 현상이 발생하는데
그래서 최근에 include 를 잘써먹고 있다. 말 그대로 #include <>같은 느낌으로 쓸 수 있다.
문제는 난 databindingd을 쓰기 때문에 부모가 되는 xml이 갖고 있는 데이터 변수를 include로 넘길 필요가 있는데
tools, app namespace를 아주 잘 써먹고 있다. 처음엔 무지 헷깔렸지만 알고 보니 간단하다.
layout에 변수명으로 지은 이름을 include에서 속성값으로 사용하면 된다. 캬~~~
확실히 편해지긴 했다. 덕분에 뷰/모델 코드는 대폭 줄었다.
관계가 이해되면서 코딩하다 보니 종전에 이상하게 만들어놓았던 부분도 고쳐 가면서 하게 되는데
이건 뭐 만들 페이지가 너무 많아서 정신이 없다.
말 그대로 요즘 4시간정도는 코딩으로 달리는 듯... 이러다 퍼질것 같다.
ㅎㅎㅎㅎㅎ
2019.05.02
```

```
#코틀린노트 27
결국 계산까지 갔다. 예전에 UI가 그려지는 과정에 대한 질문을 받았을 때 잠깐 보던 건데
난 저건 하지 말아야지 했던건데 결국 하게 되었다. 빌어먹을 변태 해상도 ㅋㅋㅋ
심플하게 커스텀으로 UI 상속 받아 onMeasure()에서 사이즈를 가공했다.
DP, Density 다 고려 되어야 하므로 수학 문제를 풀게 되었다.
예측된 값을 기준으로 계산하니 이런일이 벌어졌다.
그냥 UI 앱은 누군들 하고 있는거다 생각하는게 좋을 듯 싶다.
그냥 옆으로만 늘렸어도 된건데 ㅎㅎㅎ
2019.04.23
```

```
#코틀린노트 26
뭣 모르고 따라하기 수준으로 썼던 데이터 바인딩이 손에 익어 간다.
아무래도 Rest API 구동이 목적인 앱이다 보니 리스트가 많아지는데
리스트 뷰 + 어댑터 + 데이터 세트를 어떻게 관리하냐에 따라 코드가 이뻐진다.

리스트 뷰를 데이터 바인딩으로 엮는데 있어서 약간 억지 스럽다고 생각했던 부분이
이해가 되기 시작하고 좀 더 범용적으로 관리가 가능하다는걸 알게되었다.

그리고 데이버 바인딩을 쓰는 법이 참 많다는 것도 알게 되었다.
좀 더 다듬어야겠지만 공통화에 대한 유혹이 아주 심하다.
하지만 지금 공통화를 섯불리 하면 기존에 만든 커스텀 UI를 안쓰는 것이 의미가 없어지기 때문에
좀 더 고민하고 좀더 확실하게 설계해 봐야겠다.

유혹을 이겨내는 것도 코딩의 기술인가?

'검술을 쪼개고 쪼개 더이상 나눌 수 없을 지경에 이르어 만들어진다는 무상검법...'
이 갑자기 생각난다.

이펙티브 자바 함 봐야것다.
2019.04.19
```

```
#코틀린노트 25
드디어 앱 노가다가 시작되었다.
솔직히 그냥 원래 하던대로 만들면 벌써 끝날 일이지만
예전 프로젝트부터 고민했던 구글이 추구하는 방식으로 만들어보자가
코틀린의 시작이었고 RX의 시작이었기 때문에
MVVM + Databinding 정석으로 만들어보고 있다.

솔직히 정석인지는 모르겠다.

리사이클러 뷰에서 아이템에 바인딩하는 건 좋은데
어댑터에 바인딩할 경우 뭔가 억지스러운 코드가 들어간다.
또 static func을 만들어야 하기도 한다.

만들어 놓고 보니 공통화가 가능한 구간이 눈에 확 보인다.
Kotlin + MVVM + Databinding을 하게 되면 가장 큰 이점 중에 하나인
코드의 간결화. 상상 그 이상으로 줄어들며
여기에 Rx까지 적절히 녹이면 대량 생산?이 가능한 코드까지 뽑아낼 수 있지 않을까 생각한다.

그런데 트렌드를 기준으로 보았을 때 테스트를 생각하거나 패턴을 생각하면 이를 공통화 시키는게 맞나 싶다.
유지보수를 할 경우라면 공통화 모듈이 좋은 방향일 수도 있으나 그렇지 않을 경우도 충분히 존재한다.
이 부분은 정말 만들기 나름인 것 같다.
정답은 없다고 해야 하나.

MVP와 MVI도 녹여보고 싶은데 가능할진 모르겠다.
2019.04.16
```

```
#코틀린노트 24
음성인식을 마지막으로 테스트 코드를 마무리하였다.
음성인식은 카카오 SDK를 이용했는데 이게 참.... 애매하다.
요즘 트렌드인 도메인과 뷰의 분리는 커녕 아주 강결합이 되어 있고
안드로이드의 특성을 알면서도 오디오 제어를 전혀 못하게 해놓았다.
나역시 이전 SDK 작업때 비슷한 고민을 했었기에 왜 이렇게 했는지는 잘 알고 있다.
그래 차라리 이런 구조가 기술적 검증단계에서 안되다고 못박을 수 있는 구조이니
전략적인 면에서는 더 좋을 수도 있다. 기술자의 마음으론 답답해질 뿐이지만.
강결합된 코드를 최대한 분리해서 모듈형태로 만들어서 주입하게 해놓았다.
대부분의 모듈을 레포지터리로 관리하고 뷰모델에서 받아 쓰게 만든 구조로 해놓았는데
이건 어쩔수 없이 액티비티에 직접 주입한다.
제발 본진의 앱들은 이렇게 안만들기를.. 만들었더라도 다 업그레이드 했기를 바란다.
더 해보고 싶은게 있는데 이제는 일정에 맞춰가야지..
2019.04.03
```

```
#코틀린노트 23
뷰모델 관리
내가 만든 앱은 기본적으로 라이프 사이클 기준으로 상태 변화가 일어나면
원인을 알수없는 이유로 동일한 아이템을 여러번 그리는 현상이 보였다.
나는 당연히 onCreate ~ onDestroy를 경험하는 패턴을 기준으로 앱을 설계 했기 때문에
viewmodel에서 강조하는 onCleared를 당연히 작동시킬 줄 알았다.
허나 page lib에서는 fragment관리를 위해 fragment 자체가 replace 되어도
파괴하지 않고 메모리에 저장해 놨다가 다시 사용하는 구조인데
이로 인하여 onCreateView ~ onDestroyView 까지만 작동한다.
결국 ViewModel이 완전이 종료되지 않는 이슈가 있다.

나는 처음에 이부분이 문제라고 생각했으나
ViewModel자체가 재활용이 가능하도록 설계가 되어 있어
fragment가 사라지지 않는한 그대로 남아 있고
새로 요청을 하더라도 기존에 존재하면
그걸 가져오는 기능이 있다.

fragment를 여러개 사용할 경우 이게 맞는 본연의 기능임은 분명하나
안드로이드는 기본적으로 mvvm도 좋지만 참조에 의한 메모리릭을 아주 신경쓰는 구조이기 때문에
onCleared라는 구조를 만들어 놓았고 하나의 뷰모델을 갖고
여러군데에서 사용하는 것을 추천하지는 않는다.
뷰모델을 자신에 맞게 각각 사용하는 예제가 주로 이룬다.
그리고 우리 앱처럼 액티비티하나에 연관없는 모든 뷰를
페이지형태로 관리하는 구조에 적합하지는 않다. 

어찌되었건 새로운 사실을 알게 되었고 항상 뷰모델 생성하는 부분이
코드가 애매해서 왜이렇게 만들었지 궁금했는데
이제 그 이유를 알것같다.
처음에는 설계된 라이프사이클에 문제가 있는것으로 판단하고
모든 라이프사이클을 재정의 하는 코드를 만들었는데
fragment 관리하는 구조때문에 내가 알고 있는 방식은 쓰기 어려웠다.

나중에 파악해보니 viewmodel안에 옥저버(라이브데이터)를 인스턴트로 생성해서 쓰는데
(당연히 fragment와 함께 사라지기 때문에 메모리 관리 안함) 이게 문제가 되었다.
그래서 확실하게 fragment view 생성/소멸 시점에 라이브데이터가 생성/소멸하도록 명시하였다.
이렇게 하니 문제가 사라졌다.

fragment 때문만은 아니더라도 이 구조가 명확한것같다.
정식 MVVM은 뷰모델이 모든 라이브사이클을 관여하도록 설계가 되어 있기 때문이다.
(안드로이드는 라이프 사이클은 관여하지 않아도 된다고 강조한 부분이 있지만......)
2019. 3. 26
```

```
#코틀린노트 22
Viewpager2 라는게 나왔길래 써보려 했으나 배보다 배꼽이 더 큰 일이 터져서 캔슬.
viewpager 자체가 원래 배보다 배꼽이 더 크긴해.
recyclerview를 직접 쓸수있다는데...... 언젠간 써보자.
2019. 2. 25. 오후 6:22
```

```
#코틀린노트 21
가속 가슴 한켠에 자리잡아 있던 androidx 수술 작업을 완료하였다.
친구가 찾아준 어떤 글에서는 머지 나이트메어라는 ㄷㄷㄷㄷㄷ.
암튼 잘되니 이제 androidx로 다 처리하자.
2019. 2. 15. 오후 4:55
```

```
#코틀린노트 20
그동안은 아무생각없이 뷰모델을 N개 만들었는데 가만히 보니
A라는 동작 하나를 위해 필요한 코드가 너무 많다는 생각이 들었다.
그래서 비슷한 애들을 통합으로 만들었으나 이거 누가 쓰고 있는지 알길이 없넼ㅋㅋㅋ
AAC의 매력인 cleared()가 아무짝에 쓸모가 없어짐.
그래서 원복해야겠다. ㅎㅎㅎㅎㅎ
2019. 2. 11. 오후 5:02

뷰모델이 원래 저렇게 쓰는게 맞더라 - 2019.04.01
```

```
#코틀린노트 19
신규 프로젝트에 Dagger를 사용하고 있는데 기존에는 AndroidInjector를 사용했다.
귀차니즘의 끝에서 탄생한 어마어마한 도구임이 분명하나 이걸 안쓰는 Dagger를 쓰려니 한창 고생했다.
결국 해내긴 했는데 AndroidInjector를 쓰기로 한건 함정. ㅎㅎㅎㅎ. 뭐 이러면서 배워나가는거지.

Scope는 Dependency에 예민하다.
2019. 1. 29. 오후 2:32
```

```
#코틀린노트 18
라이브 데이터를 쓸 경우 백그라운드 스레드에서 데이터를 처리해야할 경우가 생기는데
이때는 value가 아닌 postvalue로 처리한다. 크~~~~~~~~~~~~~~~~~~~~~~~~~~~~
2018. 11. 27. 오후 3:35
```

```
#코틀린노트 17
데이터바인딩도 이제 어느정도 손에 익었고 이제는 constraint layout이닷!
일단 엄청 헷깔리긴 한데 제대로 쓰면 좋긴 하지만 GUI 담당자와 개발자간의 가이드라인도 바뀌어야 할 듯....

정말 배울게 많아.
이거 회사 제대 다니려면 학원을 다녀야할 판이로구나.....
2018. 11. 22. 오후 5:33
```

```
#코틀린노트 16
데이터 바인딩의 단점
Dagger처럼 정해진 규격에 의해 자동으로 생성되는 코드가 있는데
만약에 다른 곳에서 문제가 생겨서 전체빌드가 안되면 자동 생성 코드를 못만들게 되고
데이터바인딩 코드에서 자동생성코드가 없다고 에러를 뿜는다.
문제는 CLI 빌드는 대부분 빌드에러가 확인이 되는데
안드로이드 스튜디오에서는 빌드 로그가 넘어가버리는 경우가 있어서
그냥 자동생성코드가 존재하지 않는다는 에러만 잔뜩 보여서
결과적으로 어디가 문제였는지 파악하기 애매해진다.
기본적으로 XML에 기존보다? 많은 내용을 구현하게 되는데
이 과정에서 문제가 생기면 일단 인텔리젠트 파서가 동작하긴 하지만 C, JAVA 만큼 보여주질 못하고
빌드 에러가 났을 경우 풀스택을 다 뿌리는 경향이 있어서 정작 어디가 에러났는지 찾기가 어렵다.
제대로 만들어 놓으면 이야~~~~~ 이 소리가 나오는데
만드는 과정에서 문제가 생기면 그거 찾기가 어렵다.
2018. 10. 18. 오전 10:25
```

```
#코틀린노트 15
구성하려는 화면에 아이템이 딱히 없고 리스트만 덜렁있어서
처음에는 리스트 아이템에 대한 데이터바인딩만 해보았다.
음.. 나름 괜찮았는데 오늘은 리스트 아이템을 저장하는 구간을 데이버바인딩으로 바꾸었다.
신세계다.....
엄청 직관적이라고 해야하나?
처음엔 이해가 어려운게 함정.
2018. 10. 17. 오후 5:39
```

```
#코틀린노트 14
그냥 데이터바인딩을 쓰면 좀 낫네? 정도인데 리스트에서 사용하니 확실히 어마어마하다..
뷰홀더는 아주 심플해지고 나중에 유지보수도 편하게 처리가 가능하다.
특정 메소드를 직접 연결할 수도 있으며 임의로 import하여 처리도 가능하다.
적당히 하려했는데 하다보니 어지간한건 다 해보게 됨.
엄청 복잡하게도 사용이 가능해 보인다.
근데 그러진 말자. 이미 머릿속에 들어오는게 너무 많다. ㅋㅋㅋ
2018. 10. 16. 오후 5:39
```

```
#코틀린노트 13
데이터바인딩.......가장 별거 아니지만 가장 설명하기 난해하다.
안드로이드 초창기에 XML마져도 만지기 싫다고
모든 코드를 자바로 만드신 분을 봤는데 그때가 잠시 떠오른다. ㅎ
프로그래밍은 어떻게 만들던 최적화가 최우선이기 하나
요즘은 분명 트렌드를 따라가는 경향이 있다.
그래서 시작한 것이긴 하지만 이건 정말 설명하기가 난해하다.
간단하게 접근하면 MVVM에서 뷰와 뷰모델간의 구현코드 조차
완전 깔끔하게 분리하겠다는 의지가 강하다고 볼수있고
WPF나 MVVM을 통해서 접근한 거라면 이렇게 이해하는 것이 빠를 것 같다.
일반적으로 자바 기반 안드로이드를 하고 있었다면 뷰의 속성값들의 집합인 XML코드가
그 기능이 확장되어 구현부에 직접 접근을 하거나
Observable한 코드 운용이 가능하다고 보면 될듯.
구현부(혹은 뷰모델) 코드가 확실히 줄어들 순 있으나
새로 배우는 입장에서는 간단하게 구현할 수 있는 화면을 만들 때 까지
너무 많은 것을 알아야 시도해볼 수 있는 상황이 올수도 있고
혹은 그 반대로 알아야될 내용을 죄다 건너 뛰고
앱을 개발하는 상황이 올수도 있어 보인다.
확실한건 최근 인싸? 세트를 보게되면 코드가 엄청 줄어들고 깔끔해진다.
2018. 10. 16. 오후 3:47
```

```
#코틀린노트 12
MVC - 액티비티에서 모든 명령을 받아서 처리하고 화면 갱신을 시도 한다.

MVP - 액티비티는 뷰의 명령처리를 위해 Presenter라는 명령처리 구간을 만들어
액티비티의 상태나 뷰에서 전달되는 명령을 넘긴다.
Presenter는 이때 비지니스 로직이나 데이터 처리를 위한 모델을 자신이 갖고 있게 되는데
(MVC는 액티비티가 다 처리하므로 모델도 액티비티가 들고 있음)
뷰의 명령에 따라 모델을 적당히 가공하고 가동된 데이터를 이용하여 뷰를 갱신한다.
이때 뷰를 갱신하기 위해 Presenter는 뷰의 핸들을 액티비티로 부터 가져오게 된다.

MVVM - MVP와 기본 동작은 완전이 동일하지만 Presenter 역할을 하는 ViewModel은 뷰의 핸들을 직접 들고 있지 않는다.
(실제 내부에도 없는지는 모른다) 다만 안드로이드에서는 데이터 바인딩이란 기술을 이용하여
뷰와 뷰모델을 직접 연결하고 뷰를 통해 전달되는 명령이나
혹은 모델을 이용한 데이터 가공이후의 화면 갱신을 위해 옵저버 패턴을 활용한다.
이를 위한 전용 클래스가 존재한다.
데이터 바인딩을 사용하지 않더라도 라이브 데이터라는 기술을 이용하여 비슷하게 구현이 가능하다.

DI - MVP나 MVVM을 제대로 처리하기 위해서는 각 역할 별로 클래스를 나눠놓고 특정시점에 생성을 해야 한다.
문제는 이 생성자 구현부가 매우 지저분해질 수도 있고
변경점이 존재할 때는 생성한 모든 구간을 다 수정해야 해서 생산성이 좋지 못하다.
그래서 DI라는 기술을 이용해서 인스턴스 생성 구간을 잘 설계하면 모듈이라 불리는 DI 처리 클래스를
조작하여 관리가 편해질 수 있다.

MVP나 MVVM을 사용하는 이유 - 성능을 기대해서 만들어진 개념은 아닌 것 같다.
일단 MVC로 하면 기능이 세분화 되긴 하지만 M V C 에 해당하는 내용들이 강결합이 될 수 밖에 없어서
코드 알아보기가 어렵고 테스트는 더더욱 어려워진다.
MVP나 MVVM는 역할별로 완전 독립을 추구하는 스타일이기 때문에
(물론 완전 분리는 현실적으로 어렵다.)
특정 구간을 기준으로 테스트 모듈 작성이 쉬워진다.
제일 중요한건 코드 보기가 아주 간결해지고
(물론 해당 패턴을 알아 볼 수 있을 경우)
최근 트랜드인 보일레이트 코드를 최소화 할 수 있다.
패턴을 지켜서 코딩해야 하기 때문에 귀차니즘에 의한 코딩 유혹을
떨쳐내야 제대로 된 코드를 만들 수 있다.
(나중에 유지보수가 편하다는 것이지 만들기는 엄청 귀찮다. 처음 MVC를 시작했을 때 처럼....)
MVC에 비해 단순 반복 코드가 많아진다.
2018. 9. 7. 오후 4:44
```

```
#코틀린노트 11
내가 UI에 이렇게 까지 공을 들인 적이 있는가?
2018. 8. 22. 오후 5:39
```

```
#코틀린노트 10
아무리 생각을 해도 MVVM을 하다보니 더 지저분해보여. ㅋㅋㅋㅋ
일단 입질 왔을 때 다 만들어보자.
2018. 8. 21. 오후 4:06
```

```
#코틀린노트 9
싱글톤 레포지터리 혼종
2018. 8. 17. 오후 2:00
```

```
#코틀린노트 8
드디어 라이브 데이터의 정체를 파악했다.
2018. 8. 10. 오후 2:33
```

```
#코틀린노트 7
결국 내가 했던거네 ㅋㅋㅋㅋㅋ
코드 지저분한거 싫어서..
난 또 뭐 대단한게 있는 줄 알았다 ㅋ
2018. 8. 10. 오후 1:19
```

```
#코틀린노트 6
손대다 보니 다 뜯어 고치게 만드는 dagger2 캬~~~
2018. 8. 8. 오후 12:43
```

```
#코틀린노트 5
처음 retrofit을 알게 되었을 때도 어차피 내가 필요한 것만 쓴다는 것을 목표로 접근했었는데
지금와서 보니 결국 다 써야함.
결국 MVVM든 MVP든 거기로 가야함. 결국 대거에 손을 댐 ㅠ
배보다 배꼽이 더 큰..... 
모바일.. 더 나아가 임베디드 개발의 가장 중요한 키워드는
절약과 단축이거늘.. 이젠 복잡도가 어지간한 윈도우 프로그램 급인 거 같다.
2018. 8. 7. 오후 12:36
```

```
#코틀린노트 4
가끔씩 컴파일에러가 났을 경우
어디서 문제인지를 안알랴줌
2018. 7. 3. 오후 3:52
```

```
#코틀린노트 3
드디어 rxandroid와 room을 결합한 원형이 나왔다.
그동안 문제점이 무엇인지 찾았는데 대체할 방법을 모르겠다.
어디다 물어봐야함?
2018. 6. 22. 오후 3:20
```

```
#코틀린노트 2
액티비티를 호출할때 to 형태의 pair 값을 넘기면 get intent extra 형태로
수신측 액티비티에서 값을 확인할 수 있다.
이게 원래 되었던건지는 잘 모르겠으나 intent setextra같은 코드가 오나전 간결해진다.
2018. 6. 21. 오전 11:54
```

```
#코틀린노트 1
object로 만들면 전지전능 클래스인 싱글톤으로 구성이 된다.
책이나 자료에는 sychronize형태로 만들어진다고 했으나 디컴파일 해보면 그렇지 못하다.
thread safe형태로 가려면 아무래도 lazy를 써야 하는 듯 하다.
이것도 기본적인 구성일 때 이야기이고 인스턴스를 얻고자 할때
파라메터가 필요할 경우엔 이런것도 다 소용없고
그냥 자바에서 만들듯이 만들어야 한다.
다만 static class개념이 없으므로 object를 이용해서 만들어야 한다.
여기도 마찬가지로 sychronize처리를 해주어야 디컴파일 했을 때
내가 아는 그게 만들어진다.
어디 물어볼 것이 없는게 함정.
2018. 6. 20. 오후 1:01
```
